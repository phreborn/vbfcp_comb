/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

// class declaration include file below retrieved from workspace code storage
#include "Background.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include "RooRealVar.h"
#include "RooBinning.h"
#include <math.h>
#include "TMath.h"
///////////////////////////////////////////////////////////DEFINES BACKGROUND
double Background::dndx(double mass, double p2, double p3, double xi) const
{
    if(m_btype == 1) return TMath::Power(1-mass/13000.,p2-xi*p3) * TMath::Power(mass/13000,-p3);
    
    if(m_btype == 2) return TMath::Exp(-(2*p2+60)*mass/13000.+(2*p3+70)*pow(mass/13000.,2));
    
    if(m_btype == 3) return TMath::Exp(-p2*mass/13000.) * TMath::Power(mass/13000.,p3);
    
    if(m_btype == 4) return TMath::Exp( -(mass/13000) * p2 + (mass/13000)*(mass/13000) * p3);
    
    cout<<"ERROR: WRONG BACKGROUND"<<endl;
    
    exit(EXIT_FAILURE);
}
///////////////////////////////////////////////////////////GETS BACKGROUND INTEGRAL
double Background::Integrate(double m1, double m2, double p2, double p3, double xi) const
{
    int intopt = 306;
    
    double dndx_avg = 0.0;
    if ( intopt == 1 )
    {
        double mavg = 0.5*(m1+m2);
        dndx_avg = dndx(mavg, p2, p3, xi);
    }
    else if ( intopt == 2 )
    {
        dndx_avg = 0.5*(dndx(m1, p2, p3, xi) + dndx(m2, p2, p3, xi));
    }
    else if ( intopt == 3 )
    {
        double mavg = 0.5*(m1+m2);
        dndx_avg = 0.25*dndx(m1, p2, p3, xi) + 0.5*dndx(mavg, p2, p3, xi) + 0.25*dndx(m2, p2, p3, xi);
    }
    else if ( intopt == 301 )
    {
        double mavg = 0.5*(m1+m2);
        dndx_avg = 0.20*dndx(m1, p2, p3, xi) + 0.6*dndx(mavg, p2, p3, xi) + 0.20*dndx(m2, p2, p3, xi);
    }
    else if ( intopt == 302 )
    {
        double mavg = 0.5*(m1+m2);
        dndx_avg = 0.10*dndx(m1, p2, p3, xi) + 0.8*dndx(mavg, p2, p3, xi) + 0.10*dndx(m2, p2, p3, xi);
    }
    else if ( intopt == 303 )
    {
        double mavg = 0.5*(m1+m2);
        dndx_avg = 0.15*dndx(m1, p2, p3, xi) + 0.7*dndx(mavg, p2, p3, xi) + 0.15*dndx(m2, p2, p3, xi);
    }
    else if ( intopt == 304 )
    {
        double mavg = 0.5*(m1+m2);
        dndx_avg = 0.16*dndx(m1, p2, p3, xi) + 0.68*dndx(mavg, p2, p3, xi) + 0.16*dndx(m2, p2, p3, xi);
    }
    else if ( intopt == 305 )
    {
        double mavg = 0.5*(m1+m2);
        dndx_avg = 0.17*dndx(m1, p2, p3, xi) + 0.66*dndx(mavg, p2, p3, xi) + 0.17*dndx(m2, p2, p3, xi);
    }
    else if ( intopt == 306 )
    {
        double mavg = 0.5*(m1+m2);
        dndx_avg = 0.165*dndx(m1, p2, p3, xi) + 0.67*dndx(mavg, p2, p3, xi) + 0.165*dndx(m2, p2, p3, xi);
    }
    else if ( intopt == 4 )
    {
        double f1 = 1/6.0;
        double f2 = 2*f1;
        double fm1 = 1/3.0;
        double fm2 = 2/3.0;
        dndx_avg = f1*dndx(m1, p2, p3, xi) + f2*dndx(fm2*m1+fm1*m2, p2, p3, xi) + f2*dndx(fm1*m1+fm2*m2, p2, p3, xi) + f1*dndx(m2, p2, p3, xi);
    }
    else if ( intopt == 5 )
    {
        dndx_avg = 0.125*(dndx(m1, p2, p3, xi) + dndx(m2, p2, p3, xi)) +
        0.25*(dndx(0.75*m1+0.25*m2, p2, p3, xi) + dndx(0.5*m1+0.5*m2, p2, p3, xi) + dndx(0.25*m1+0.75*m2, p2, p3, xi));
    }
    
    return dndx_avg*fabs(m1-m2);
}
///////////////////////////////////////////////////////////
ClassImp(Background)
///////////////////////////////////////////////////////////
Int_t Background::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
{
    if (matchArgs(allVars, analVars, x )) return 1;
    return 0;
}
///////////////////////////////////////////////////////////
Double_t Background::analyticalIntegral(Int_t code, const char* /*rangeName*/) const
{
    assert(code==1) ;
    
    Double_t area = 0;

    RooAbsBinning &binning = (dynamic_cast<RooRealVar*>( x.absArg()))->getBinning(); // get default binning
    for (Int_t i_bin = 0; i_bin < binning.numBins(); i_bin++) {
      const Double_t xmin = binning.binLow(i_bin); 
      const Double_t xmax = binning.binHigh(i_bin); 

      area += Integrate(xmin, xmax, p2, p3, xi);
    }
    
    return area;
}
///////////////////////////////////////////////////////////
Background::Background(const char *name, const char *title,
                       RooAbsReal& _x,
                       RooAbsReal& _p2,
                       RooAbsReal& _p3,
                       RooAbsReal& _xi,
                       int btype) :
RooAbsPdf(name,title),
x("x","x",this,_x),
p2("p2","p2",this,_p2),
p3("p3","p3",this,_p3),
xi("xi","xi",this,_xi),
m_btype(btype)
{
}
///////////////////////////////////////////////////////////
Background::Background(const Background& other, const char* name) :
RooAbsPdf(other,name),
x("x",this,other.x),
p2("p2",this,other.p2),
p3("p3",this,other.p3),
xi("xi",this,other.xi),
m_btype(other.m_btype)
{
}
///////////////////////////////////////////////////////////
Double_t Background::evaluate() const
{
    RooAbsBinning &binning = (dynamic_cast<RooRealVar*>( x.absArg()))->getBinning(); // get default binning

    const Int_t bin = binning.binNumber(x);

    const Double_t xmin = binning.binLow(bin);
    const Double_t xmax = binning.binHigh(bin);

    const Double_t bc = Integrate(xmin, xmax, p2, p3, xi) / fabs(xmax - xmin);

    return bc;
}


